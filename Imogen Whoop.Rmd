---
title: "Metric Analysis"
author: "Imogen Meers"
date: "26/1/24"
output: html_document
---

# Personal Whoop Analysis: What makes the Optimal Taper?

## Motivation

Taper is one of the hardest but also most important parts of the swimming cycle to execute. Years of training can come to fruition with a good taper, but swimmers often fall short if they "miss" their taper.

This is an important problem to me personally as I am using my own Whoop data from my college experience (2020-2025) to decipher what are important features of taper for me and what I can optimize/avoid in order to have a "peak performance."

Whilst it will be useful to see how Whoop affects taper and competition, it is important to note that this analysis is a small snapshot of my actions that affect my swimming. I am not including injury, illness, nutrition or recovery data, which would help to draw a better picture of my performance. I am, however, hoping that significant changes in these areas will be reflected in my personal metrics and thus be considered.

## Previous Work

There have been a number of studies on wearable tech metrics and their accuracy and predictability for factors of performance, recovery and strain. 

One study I found that was particularly interesting and related to my analysis is the thesis of Emily Lundstrom, a Masters student at Penn State University called _Effectiveness of Wearable Technology for Predicting Measures of Metabolism and Performance in Collegiate Division 1 Swimmers_. She found a negative correlation between strain and time trial performance in female swimmers as well as a positive correlation between HRV and suppressed metabolic rate. These are both significant findings when looking at Whoop metrics in swimmers and are similar to what I would expect to find in my own analysis. 


## Problem Framing

After an exploratory analysis of the different data sets collected by Whoop, which include physiology, sleep and workouts, I intend to analyse different parts of this problem.

1. What factors contribute the most to my peak performances?
  For this, I will use both my own derived variables such as AC ratio, and Whoop's derived metrics to create a model that predicts performance and extract variable importance. 
  
  
2. How my performance varies between events, based on taper?
  For this, I will extract more data from my swims and look at distribution of splits and overall results for 50 vs 100 and how factors differ between good performances in front-end vs. back-end speed.


## Data Overview

My data sources will be:

Whoop metrics from July 2020 to Jan 2025

  - Whoop derived variables:
      - Physiological
      - Sleep
      - Workout
      
  - Self derived variables
      - AC Ratios
      - Rolling average
      - Workout description indicator variables
  
swimcloud.com meet results from July 2020 to Jan 2025

This data is generally pretty clean and comprehensive. I have worn my Whoop consistently for the past 4 years with only a few days missing data. I do take off my Whoop when I am competing, but this should not affect my analysis as I am using results-based data to evaluate success of a meet rather than in-meet Whoop metrics.

The swimcloud website is also a reliable data source. They report times for all meets and splits for most, meaning there is no need to impute data here.

## Bibliography

Lundstrom, E. (2020). Effectiveness of Wearable Technology for Predicting Measures of Metabolism and Performance in Collegiate Division 1 Swimmers. Master's Thesis, Pennsylvania State University1. Retrieved from Pennsylvania State University Electronic Theses and Dissertations.

## Preliminary EDA

Let's load in the packages we are going to use for the analysis:

```{r warning=FALSE}
library(ggplot2) # load ggplot2
library(ggdark) # load ggdark
library(data.table) # load data.table
library(dplyr)
library(lubridate)
library(tidyr)
library(stringr)
```



```{r}
phys_cycles <- read.csv("physiological_cycles.csv")
dim(phys_cycles) # View dimensions of the data
plot_data <- phys_cycles 
colnames(plot_data) <- c("cycle_start", "cycle_end", "cycle_tzone", "recovery", "rhr", "hrv", "skin_temp", "blood_oxygen", "day_strain", "energy_burned", "maxhr", "ahr", "sleep_onset", "wake_onset", "sleep_performance", "resp_rate", "asleep_dur", "in_bed_dur", "light_sleep", "deep_sleep", "rem", "awake_dur", "sleep_need", "sleep_debt", "sleep_efficiency", "sleep_consistency")

summary(plot_data) # Summarise metric data
```
This data has 1477 rows dating from July 2020 to present. It includes general data on physiological cycles including sleep and  daily metrics.
```{r}


# Create a mapping of time zone offsets to Olson names
tzone_mapping <- c(
  "UTC-05:00" = "America/New_York",
  "UTCZ" = "UTC",
  "UTC-06:00" = "America/Chicago",
  "UTC-07:00" = "America/Denver",
  "UTC-04:00" = "America/Halifax",
  "UTC+02:00" = "Europe/Bucharest",
  "UTC+01:00" = "Europe/Paris"
)

plot_data <- plot_data %>%
  mutate(cycle_olson = tzone_mapping[cycle_tzone])

# Convert cycle_start to POSIXct
plot_data <- plot_data %>% rowwise() %>%
  mutate(cycle_start = ymd_hms(cycle_start, tz = cycle_olson),
         cycle_end = ymd_hms(cycle_end, tz = cycle_olson),
         wake_onset = ymd_hms(wake_onset, tz = cycle_olson),
         sleep_onset = ymd_hms(sleep_onset, tz = cycle_olson),) %>% ungroup()





#grade mapping
# Define the mapping function
grade_mapping <- function(date) {
  if (date >= as.Date("2020-08-01") & date < as.Date("2021-05-01")) {
    return("Freshman")
  } else if (date >= as.Date("2021-05-01") & date < as.Date("2022-05-01")) {
    return("Sophomore")
  } else if (date >= as.Date("2022-05-01") & date < as.Date("2023-05-01")) {
    return("Junior")
  } else if (date >= as.Date("2023-05-01") & date < as.Date("2024-05-01")) {
    return("Senior")
  } else if (date >= as.Date("2024-05-01")) {
    return("Grad")
  } else {
    return(NA)  # In case date does not fall within any range
  }
}

plot_data <- plot_data %>% filter(!is.na(cycle_start) & !is.na(cycle_end) & !is.na(wake_onset))


# Apply the function to the data frame
plot_data <-  plot_data %>% mutate(grade = sapply(wake_onset, grade_mapping))
summary(plot_data)

days_since_mapping <- function(grade, date) {
  if (is.na(grade)){
    return(NA)
  }
  
  
  if (grade == "Freshman") {
    reference_date = "2020-05-01"
    return(as.numeric(difftime(date, reference_date, units = "days")))
  } else if (grade == "Sophomore") {
    reference_date = "2021-05-01"
    return(as.numeric(difftime(date, reference_date, units = "days")))
  } else if (grade == "Junior") {
    reference_date = "2022-05-01"
    return(as.numeric(difftime(date, reference_date, units = "days")))
  } else if (grade == "Senior") {
      reference_date = "2023-05-01"
      return(as.numeric(difftime(date, reference_date, units = "days")))
  } else {
      reference_date = "2024-05-01"
      return(as.numeric(difftime(date, reference_date, units = "days")))
  }
}


# Apply the function to the data frame
plot_data <-  plot_data %>% mutate(days_since = mapply(days_since_mapping, grade, wake_onset))

melted_data <- plot_data %>% select(-c(cycle_start, cycle_end, cycle_tzone, cycle_olson, sleep_onset )) %>% pivot_longer(cols = -c(wake_onset, grade, days_since), names_to = "metric", values_to= "value")

```

## Physiological Metrics over Years

```{r}

metric_plot <- melted_data %>% mutate(reference = ifelse(month(wake_onset) == 8, "pre season", ifelse(month(wake_onset) %in% c(5,6,7), "summer", ifelse(month(wake_onset) == 2, "conference", NA))))

metrics = c("rhr", "hrv", "maxhr", "recovery")
for (i in 1:4){
  g_metric <- ggplot(metric_plot[metric_plot$metric == metrics[i],], # Set data
              aes(x = days_since, y = value, color = grade))+ # Set aesthetics
  #geom_jitter(alpha = 0.2, height =0.1, aes(fill = metric))+ # Add points 
    
  geom_vline(xintercept = metric_plot[metric_plot$reference == "pre season",]$days_since, linetype = "dotted", color = "blue") + # Add vertical reference line
    
  geom_vline(xintercept = metric_plot[metric_plot$reference == "conference",]$days_since, linetype = "dotted", color = "green") + # Add vertical reference line
    
  geom_smooth(se = FALSE) + # Add smooting line
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + # Turn off grid
  dark_theme_minimal() + # Set theme
  labs(title = paste0("Whoop Metrics -- ", metrics[i]), # Set labels
       color = "Year") +
      annotate("text", x = 110, y = max(metric_plot[metric_plot$metric == metrics[i] & !is.na(metric_plot$value),]$value) -5, label = "pre season", color = "blue") + # Label for vertical line
    annotate("text", x = 290, y = max(metric_plot[metric_plot$metric == metrics[i] & !is.na(metric_plot$value),]$value) -5, label = "conference", color = "green") + # Label for vertical line
  guides(fill = "none") 

# Generate plot
print(g_metric)

}
# Turn off dark mode
invert_geom_defaults()

```


## Meet Overview

```{r}
all_swim <- read.csv("all_swim_results.csv")

```

```{r}
swim_df <- all_swim %>% mutate(Date = str_replace_all(Date, "â€“\\d{1,2}", ""), Results = str_replace_all(Results, "\\[|'|\\]|%|\\+", "")) %>% 
  mutate(Date = mdy(Date)) %>% 
    separate(Results, into = c("1", "2", "3"), sep = "\\), \\(", remove = TRUE) %>% 
      pivot_longer(cols = c("1", "2", "3"), names_to = "Event_Num", values_to = "Results")  %>% 
        mutate(Results = str_replace_all(Results, "\\(|\\)", "")) %>% 
          separate(Results, into = c("Event", "Time", "Season_Improvement"), sep=",") %>%
          mutate(Time = trimws(Time), Season_Improvement = trimws(Season_Improvement))  %>% 
            mutate(Season_Improvement = as.numeric(Season_Improvement))

imputed <- swim_df %>% mutate(Time = ifelse(Time == "", NA, Time), Event = ifelse(Event == "", NA, Event)) %>% mutate(Season_Improvement = ifelse(!is.na(Time) & is.na(Season_Improvement), 0, Season_Improvement))

head(imputed)
plot_bar <- imputed %>% filter(!is.na(Event)) %>% mutate(Best = ifelse(Event %in% c("100 Y Free", "50 Y Free", "100 Y Back"), 1, 0))
ggplot(data = plot_bar, aes(x=as.factor(Event), fill = as.factor(Best))) + 
  geom_bar() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  guides(fill = "none") +
  labs(title = "Distribution of Events in College", subtitle = "2020-2025", x ="events")
```

```{r}

summary_imp <- imputed %>% group_by(Date) %>% summarise(mean_imp = mean(Season_Improvement, rm.na = TRUE), max_imp = max(Season_Improvement, rm.na = TRUE)) %>% na.omit()

#get week summary for improvement so we can match it with weekly sleep and strain
summary_week <- summary_imp %>%
  mutate(week = floor_date(Date, "week")) %>%
  group_by(week) %>%
  summarise(mean_imp = mean(mean_imp),
            max_imp = max(max_imp))

summary_week$week = as.POSIXct.Date(summary_week$week)


```

## Sleep Metrics over the Years

```{r}
sleep = read.csv("sleeps.csv")
colnames(sleep) = c("cycle_start", "cycle_end", "cycle_tzone", "sleep_onset", "wake_onset", "performance", "resp_rate", "asleep_dur", "in_bed_dur", "light_sleep", "deep_sleep", "rem", "awake", "sleep_need", "sleep_debt", "efficiency", "consistency", "nap")

sleep_data <- sleep %>%
  mutate(cycle_olson = tzone_mapping[cycle_tzone])

# Convert cycle_start to POSIXct
sleep_data <- sleep_data %>%
  rowwise() %>%
  mutate(cycle_start = ymd_hms(cycle_start, tz = cycle_olson)) %>% 
  mutate(cycle_end = ymd_hms(cycle_end, tz = cycle_olson)) %>%
  mutate(sleep_onset = ymd_hms(sleep_onset, tz = cycle_olson)) %>% 
  mutate(wake_onset = ymd_hms(wake_onset, tz = cycle_olson)) %>% ungroup()


sleep_data <- sleep_data %>% select(-c(cycle_start, cycle_end, sleep_onset, cycle_tzone, cycle_olson))

sleep_data <-  sleep_data %>% filter(wake_onset >= as.Date("2020-08-01")) %>% mutate(grade = sapply(wake_onset, grade_mapping))

# Apply the function to the data frame
sleep_data <-  sleep_data %>% mutate(days_since = mapply(days_since_mapping, grade, wake_onset)) %>% select(-nap)

melted_data <- sleep_data %>% pivot_longer(cols = -c(wake_onset, grade, days_since), names_to = "metric", values_to= "value")

```


```{r}

metric_plot <- melted_data %>% mutate(reference = ifelse(month(wake_onset) == 8, "pre season", ifelse(month(wake_onset) %in% c(5,6,7), "summer", ifelse(month(wake_onset) == 2, "conference", NA))))

summary(metric_plot)

metrics = c("efficiency", "performance", "sleep_debt", "rem")
for (i in 1:4){
  g_metric <- ggplot(metric_plot[metric_plot$metric == metrics[i],], # Set data
              aes(x = days_since, y = value, color = grade))+ # Set aesthetics
  #geom_jitter(alpha = 0.2, height =0.1, aes(fill = metric))+ # Add points 
    
  geom_vline(xintercept = metric_plot[metric_plot$reference == "pre season",]$days_since, linetype = "dotted", color = "blue") + # Add vertical reference line
    
  geom_vline(xintercept = metric_plot[metric_plot$reference == "conference",]$days_since, linetype = "dotted", color = "green") + # Add vertical reference line
    
  geom_smooth(se = FALSE) + # Add smooting line
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + # Turn off grid
  dark_theme_minimal() + # Set theme
  labs(title = paste0("Whoop Metrics -- ", metrics[i]), # Set labels
       color = "Year") +
      annotate("text", x = 110, y = max(metric_plot[metric_plot$metric == metrics[i] & !is.na(metric_plot$value),]$value) -5, label = "pre season", color = "blue") + # Label for vertical line
    annotate("text", x = 290, y = max(metric_plot[metric_plot$metric == metrics[i] & !is.na(metric_plot$value),]$value) -5, label = "conference", color = "green") + # Label for vertical line
  guides(fill = "none") 

# Generate plot
print(g_metric)

}
# Turn off dark mode
invert_geom_defaults()
```
## Sleep on Performance
```{r}

### Sleep

plot_sleep = melted_data %>%  filter(metric %in% c("asleep_dur", "rem", "deep_sleep")) %>% mutate(week = floor_date(wake_onset, "week")) %>%
  group_by(week, metric) %>%
  summarise(mean = mean(value, na.rm = TRUE))

plot_sleep$week = as.Date(plot_sleep$week)
summary_week$week = as.Date(summary_week$week)

merged = merge(summary_week, plot_sleep, by = "week")

g_sleep1 = ggplot(merged, # Set data
              aes(y = mean, x = max_imp, color = metric)) + geom_smooth() +
  labs(x=" Max Performance Improvement %", y="Metric Mean (mins)", title = "The effect of sleep on max performance improvement") # Set aesthetics

g_sleep2 = ggplot(merged, # Set data
              aes(y = mean, x = mean_imp, color = metric)) + geom_smooth() +
  labs(x="Mean Performance Improvement %", y="Metric Mean (mins)", title = "The effect of sleep on mean performance improvement") # Set aesthetics
g_sleep1
g_sleep2
```
At the highest values of deep and REM sleep, performance either increased the most or decreased the most. This could be explained by the fact more sleep has a positive effect of performance but also more sleep can indicate some other underlying problem such as sickness or fatigue. 

## Strain on Performance

```{r}
### Strain
strain_week = plot_data %>% select(wake_onset, day_strain) %>% mutate(week =floor_date(wake_onset, "week")) %>%
  group_by(week) %>%
  summarise(strain_mean = mean(day_strain, na.rm = TRUE))

strain_week$week = as.Date(strain_week$week)
merged1 = merge(summary_week, strain_week,  by = "week")

colnames(strain_week)
g_strain1 = ggplot(merged1, # Set data
              aes(y = strain_mean, x = mean_imp)) + geom_smooth() +
  labs(x="MeanPerformance Improvement %", y= "Mean Day Strain", title = "The effect of strain on mean performance improvement") # Set aesthetics
g_strain1

g_strain2 = ggplot(merged1, # Set data
              aes(y = strain_mean, x = max_imp)) + geom_smooth() +
  labs(x="Max Performance Improvement %", y= "Mean Day Strain", title = "The effect of strain on max performance improvement") # Set aesthetics
g_strain2

```
Interestingly, there is not a linear relationship between strain and % improvement. It shows that a mean daily strain in the week leading up to my best overall performances (mean) is not the least but a little above, meaning I still kept some intensity in my workouts.

When we look at max performance improvement, which is looking at when I do the best in my best event compared to the season, for improvements 3% or better the strain in consistently around 14. But if the week strain is too low (around 11) or too high (around 15.5), then my best improvement drops off.



## Pre-Competition Workouts
```{r}
conference_dates = c(
  "Freshman" = "02-25-2021", 
  "Sophomore" = "02-22-2022",
  "Junior" = "02-13-2023",
  "Senior" = "02-22-2024")

midseason_dates = c(
  "Freshman" = "11-20-2020", 
  "Sophomore" = "11-20-2021", 
  "Junior" = "11-17-2022",
  "Senior" = "11-16-2023",
  "Grad" = "11-21-2024")


workouts = read.csv("workouts.csv")
workouts = workouts[,c(1:16)]
colnames(workouts) = c("cycle_start", "cycle_end", "cycle_tzone", "workout_start", "workout_end", "dur", "activity", "activity_strain", "cals", "max_hr", "av_hr", "zone1", "zone2", "zone3", "zone4", "zone5")

workouts$date = as.Date(workouts$workout_start)

workouts = workouts %>% select(-c(cycle_start, cycle_end, cycle_tzone, cals, max_hr, av_hr)) %>% mutate(workout_start = ymd_hms(workout_start), workout_end = ymd_hms(workout_end)) %>%
    mutate(morning = ifelse(format(workout_start, "%H:%M:%S") < "12:00:00", 1, 0))

sessions <- workouts %>%
  select(morning, activity, date, dur, activity_strain) %>% 
  group_by(date) %>%
  summarise(
    total_dur = sum(dur),
    max_strain = max(activity_strain),
    count_morning = sum(morning == 1),
    count_afternoon = sum(morning == 0)
  )

activities = workouts %>%
  group_by(date, activity) %>%
  summarise(count = n()) %>%
  ungroup() %>%   pivot_wider(names_from = activity, values_from = count, values_fill = list(count = 0))  %>%
  rename_at(vars(-date), ~ paste0(., "_count")) %>% select(date, Swimming_count, Weightlifting_count, Activity_count)
 
workout_data = merge(activities, sessions, by ="date")
workout_data$date = as.POSIXct(workout_data$date)
workout_data <-  workout_data %>% mutate(grade = sapply(date, grade_mapping)) %>% na.omit()


pre_meet = workout_data %>% mutate(conf_date = mdy(conference_dates[grade]), midseason_date = mdy(midseason_dates[grade])) %>% filter(conf_date-21  <= date & date <= conf_date | (midseason_date-21  <= date & date <= midseason_date)) %>% 
  mutate(days_til1 = (as.numeric(difftime(conf_date, date, units = "days"))))%>% 
  mutate(days_til2 = (as.numeric(difftime(midseason_date, date, units = "days")))) %>% 
  rowwise() %>% mutate(days_til = ifelse(days_til2 >= 0, min(days_til2, days_til1), max(days_til2, days_til1))) %>% ungroup() %>% select(-days_til1, -days_til2) %>% mutate(event =ifelse( abs(difftime(conf_date, date)) > abs(difftime(midseason_date, date)),  "conference", "midseason"))

 
```

```{r}

metrics = c("max_strain", "total_dur")

  pre_plot = pre_meet %>% select(days_til, max_strain, total_dur, event, grade) %>% pivot_longer(cols = -c(days_til, event, grade), names_to = "metric", values_to = "value") 
  
  g_preconf <- ggplot(pre_plot[pre_plot$metric == metrics[1] & pre_plot$event == "conference",], # Set data
              aes(x = days_til, y = value, color = grade) )+ # Set aesthetics

    
  geom_smooth(se = FALSE) + # Add smooting line
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + # Turn off grid
  dark_theme_minimal() + # Set theme
  labs(title = "Whoop Metrics -- Pre Conference", subtitle = metrics[1], # Set labels
       color = "Year", "Max Whoop Strain per Day") +
  scale_x_reverse()

# Generate plot
print(g_preconf)
  
  g_preconf1 <- ggplot(pre_plot[pre_plot$metric == metrics[2] & pre_plot$event == "conference",], # Set data
              aes(x = days_til, y = value, color = grade) )+ # Set aesthetics

    
  geom_smooth(se = FALSE) + # Add smooting line
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + # Turn off grid
  dark_theme_minimal() + # Set theme
  labs(title = "Whoop Metrics -- Pre Conference", subtitle = metrics[2], # Set labels
       color = "Year", y = "Mins per Day")+
  scale_x_reverse()

# Generate plot
print(g_preconf1)
```
This shows how many workouts changed when approaching two major meets this year. My most successful year, Senior year, I kept at least one of my practices with high intensity and dropped that intensity dramatically with around a week to go. There was a similar pattern with total workout duration per day, but the drop happened early around 10 days previous.

```{r}
  g_premid <- ggplot(pre_plot[pre_plot$metric == metrics[1] & pre_plot$event == "midseason",], # Set data
              aes(x = days_til, y = value, color = grade) )+ # Set aesthetics

    
  geom_smooth(se = FALSE) + # Add smooting line
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + # Turn off grid
  dark_theme_minimal() + # Set theme
  labs(title = "Whoop Metrics -- Pre Mid", subtitle = metrics[1], # Set labels
       color = "Year", "Max Whoop Strain per Day")+
  scale_x_reverse()

# Generate plot
print(g_premid)


  
  g_premid1 <- ggplot(pre_plot[pre_plot$metric == metrics[2] & pre_plot$event == "midseason",], # Set data
              aes(x = days_til, y = value, color = grade) )+ # Set aesthetics

    
  geom_smooth(se = FALSE) + # Add smooting line
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + # Turn off grid
  dark_theme_minimal() + # Set theme
  labs(title = "Whoop Metrics -- Pre Mid", subtitle = metrics[2], # Set labels
       color = "Year", y = "Mins per Day")+
  scale_x_reverse()

# Generate plot
print(g_premid1)

```
There is a lot less significant pattern approaching mid-season as there is less emphasis on resting for this meet. Interesting my best two years, junior and senior, had completely different approaches to taper.

## EDA Findings

Based on my EDA and my knowledge of how I have swam over the years, there are certain factors that seem to affect my performance. I will use these derived variables for the time leading into meets

**From the sleep metrics:**
- REM sleep (week before)
- Deep sleep (week before)
- Sleep efficiency (week before)

**From workout metrics:**
- mean daily workout duration (2 weeks before)
  - swims
  - mornings
- mean daily strain (2 weeks before)
- max daily workout strain (2 weeks before)
- A:C ratio for each aerobic zone (7:28)

**From physiology metrics:**
- mean max daily HR
- mean RHR
- mean HRV





```{r Get top 5 event results as output for model}
library(readxl)
top5 <- read_excel("swim_top5.xlsx") %>%
  group_by(Date, Event) %>%
  mutate(SwimNum = dense_rank(desc(row_number()))) 

back2 <- read.delim("./back2.txt", comment.char="#")

back2 <- back2 %>% select(-X) %>% separate(Time, into = c("Min", "Sec"), sep = ":") %>% mutate(Time = as.numeric(Min)*60 + as.numeric(Sec), Event = "200 Y Back", Date = mdy(Date)) %>% select(-Min, -Sec) %>% 
  group_by(Date, Event) %>%
  mutate(SwimNum = dense_rank(desc(row_number()))) 

top5 <- rbind(top5, back2)

top5 %>% ungroup()
top5 <- top5  %>% group_by(Event) %>% arrange(Event, Date, SwimNum)
pb = 1000
pb_col = c() 
imp_col = c()
prev_event = ""

for (i in 1:nrow(top5)) {
  row <- top5[i, ]
  event = row$Event
  
  if (event == prev_event & row$Time <= pb){
      pb_col = c(pb_col, 1)
      
      imp = -(top5[i, ]$Time - pb)/top5[i, ]$Time
      
      imp_col = c(imp_col, imp)
      
      pb = top5[i, ]$Time
  } else if(event != prev_event){ #first time swam new event
    
      pb_col = c(pb_col, 1)
      imp_col = c(imp_col, 0)
      pb = top5[i, ]$Time
  } else {
      pb_col = c(pb_col, 0)
      imp = -(top5[i, ]$Time - pb)/top5[i, ]$Time
      imp_col = c(imp_col, imp)

  }
  
  prev_event = row$Event
  
  
}
top5$PB = pb_col
top5$Imp= imp_col
head(top5)
```
To do:
- derive ac ratios for all zones, strains
- derive lags for all sleep
- count number of workouts, mornings in lag
- run models for all and individual events

- cluster performances by metrics do any performances stand out?
- lasso correlation between imp and anything?





```{r}

```





## Next Ideas: 

cumulative sum of mornings/swims
a:C ratio for anything, aerobic zones 7:28
weekend vs weekday